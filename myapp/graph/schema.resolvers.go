package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/ballinboys/myapp/graph/model"
)

type FlaskRequest struct {
	Text string `json:"text"`
}
type FlaskResponse struct {
	Summary string `json:"summary"`
}

// CreateSummary is the resolver for the createSummary field.
func (r *mutationResolver) CreateSummary(ctx context.Context, input string) (*model.Summary, error) {
	// Baca ML service URL dari environment variable
	mlURL := GetMLServiceURL()
	if mlURL == "" {
		return nil, fmt.Errorf("ML_SERVICE_URL environment variable not set")
	}

	reqBody, err := json.Marshal(FlaskRequest{Text: input})
	if err != nil {
		return nil, fmt.Errorf("marshal request: %v", err)
	}

	httpReq, err := http.NewRequestWithContext(ctx, "POST", mlURL, bytes.NewBuffer(reqBody))
	if err != nil {
		return nil, fmt.Errorf("create http request: %v", err)
	}
	httpReq.Header.Set("Content-Type", "application/json")

	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("http request failed: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("flask server returned status %d", resp.StatusCode)
	}

	var flaskResp FlaskResponse
	if err := json.NewDecoder(resp.Body).Decode(&flaskResp); err != nil {
		return nil, fmt.Errorf("decode response: %v", err)
	}

	var id int
	var created time.Time
	err = r.DB.QueryRow(
		"INSERT INTO summaries (input, summary) VALUES ($1, $2) RETURNING id, created_at",
		input, flaskResp.Summary,
	).Scan(&id, &created)
	if err != nil {
		return nil, fmt.Errorf("insert summary: %v", err)
	}

	return &model.Summary{
		ID:        fmt.Sprint(id),
		Input:     input,
		Summary:   flaskResp.Summary,
		CreatedAt: created.Format(time.RFC3339),
	}, nil
}

// Summaries is the resolver for the summaries field.
func (r *queryResolver) Summaries(ctx context.Context) ([]*model.Summary, error) {
	rows, err := r.DB.Query("SELECT id, input, summary, created_at FROM summaries ORDER BY id DESC")
	if err != nil {
		return nil, fmt.Errorf("query summaries: %v", err)
	}
	defer rows.Close()

	var results []*model.Summary
	for rows.Next() {
		var s model.Summary
		var created time.Time
		if err := rows.Scan(&s.ID, &s.Input, &s.Summary, &created); err != nil {
			return nil, fmt.Errorf("scan summary: %v", err)
		}
		s.CreatedAt = created.Format(time.RFC3339)
		results = append(results, &s)
	}
	return results, nil
}

// SummaryByID is the resolver for the summaryByID field.
func (r *queryResolver) SummaryByID(ctx context.Context, id string) (*model.Summary, error) {
	idInt, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("format ID tidak valid: %v", err)
	}
	row := r.DB.QueryRow("SELECT id, input, summary, created_at FROM summaries WHERE id = $1", idInt)

	var s model.Summary
	var created time.Time
	if err := row.Scan(&s.ID, &s.Input, &s.Summary, &created); err != nil {
		return nil, fmt.Errorf("gagal query summaryByID: %v", err)
	}
	s.CreatedAt = created.Format(time.RFC3339)
	return &s, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	type FlaskRequest struct {
	Text string `json:"text"`
}
type FlaskResponse struct {
	Summary string `json:"summary"`
}
*/
